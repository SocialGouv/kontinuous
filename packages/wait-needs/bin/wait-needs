#!/usr/bin/env node

const rolloutStatusWatch = require("~common/utils/rollout-status-watch")
const logger = require("~common/utils/logger")

const runWaitNeeds = async ({ waitNeeds, timeout = 900 }) => {
  const interceptor = {}

  setTimeout(() => {
    interceptor.stop = true
    setTimeout(() => {
      process.exit(1)
    }, 1000)
  }, timeout * 1000)

  const promises = []
  for (const { namespace, selectors } of waitNeeds) {
    const selector = selectors
      .map(([label, value]) => `${label}=${value}`)
      .join(",")

    promises.push(
      new Promise(async (resolve, reject) => {
        try {
          logger.info({ namespace, selector }, `watching`)
          const result = await rolloutStatusWatch({
            namespace,
            selector,
            interceptor,
            // rolloutStatusProcesses,
            // kubeconfig,
            // kubecontext,
            logger,
          })
          resolve(result)
        } catch (err) {
          reject(err)
        }
      })
    )
  }

  const results = await Promise.allSettled(promises)
  const errors = []
  for (const result of results) {
    const { status } = result
    if (status === "rejected") {
      const { reason } = result
      if (
        reason &&
        (typeof reason !== "object" ||
          Object.keys(reason) > 0 ||
          (reason instanceof Error && reason.message))
      ) {
        logger.error({ reason }, "rollout-status exec error")
        if (reason instanceof Error) {
          errors.push(reason.message)
        } else {
          errors.push(reason)
        }
      }
    } else if (status === "fulfilled") {
      const { value } = result
      if (value.success === false) {
        errors.push(value.error)
      }
    } else {
      logger.fatal({ result }, `unexpected promise result`)
    }
  }
  if (errors.length > 0) {
    logger.error({ errors }, "required dependencies can be satistfied")
    process.exit(1)
  } else {
    logger.info("all dependencies are ready")
    process.exit(0)
  }
}

const main = async () => {
  const jsonWaitNeeds = process.env.WAIT_NEEDS
  const waitNeeds = JSON.parse(jsonWaitNeeds)
  let timeout = process.env.TIMEOUT
  if (timeout) {
    timeout = parseInt(timeout, 10)
  } else {
    timeout = undefined
  }
  await runWaitNeeds({ waitNeeds, timeout })
}

main()
